#!/bin/bash

function get_filepath_from_volumes(){
  local FILENAME="$1"
  local VOLUMES="$2"
  local VOL_SRC
  local VOL_DEST
  local FILEPATH

  [[ -z "${VOLUMES}" ]] && VOLUMES="$(docker inspect k8sup | jq -r '.[0].HostConfig.Binds[]' | cut -d ':' -f 1-2)"
  for VOL in ${VOLUMES}; do
    VOL_SRC="$(echo "${VOL}" | cut -d ':' -f 1)"
    VOL_DEST="$(echo "${VOL}" | cut -d ':' -f 2)"
    FILEPATH="$(find "${VOL_DEST}" -type f -name "${FILENAME}" -o -type l -name "${FILENAME}" 2>/dev/null | head -n 1)"
    if [[ -n "${FILEPATH}" ]]; then
      echo "${FILEPATH}"
      return 0
    fi
  done

  return 1
}

function rbd_env_detector(){
  local RBD_CMD_PATH
  local RBD_KO_PATH
  local MODPROBE_CMD_PATH
  local DOCKER_CMD_PATH
  local LIBDEVMAPPER_SO_PATH
  local VOLUMES="$(docker inspect k8sup | jq -r '.[0].HostConfig.Binds[]' | cut -d ':' -f 1-2)"

  [[ -n "$(echo "${VOLUMES}" | grep "/usr/lib")" ]] \
    && [[ -n "$(echo "${VOLUMES}" | grep "/bin")" ]] \
    && RBD_CMD_PATH="$(get_filepath_from_volumes "rbd" "${VOLUMES}")" \
    && RBD_KO_PATH="$(get_filepath_from_volumes "rbd.ko" "${VOLUMES}")" \
    && MODPROBE_CMD_PATH="$(get_filepath_from_volumes "modprobe" "${VOLUMES}")" \
    && DOCKER_CMD_PATH="$(get_filepath_from_volumes "docker" "$(echo "${VOLUMES}" | grep "/bin")")" \
    && LIBDEVMAPPER_SO_PATH="$(get_filepath_from_volumes "libdevmapper.so.*" "$(echo "${VOLUMES}" | grep "/usr/lib")")" \
    || { echo "RBD mounting is not available on this host." 1>&2 && return 1; }

  echo "RBD mounting is available on this host." 1>&2

  local RBD_OPTIONS="--volume=${RBD_CMD_PATH}:/bin/rbd:ro \
        --volume=${RBD_KO_PATH}:${RBD_KO_PATH}:ro \
        --volume=${MODPROBE_CMD_PATH}:/sbin/modprobe:ro \
        --volume=${DOCKER_CMD_PATH}:/bin/docker:ro \
        --volume=${LIBDEVMAPPER_SO_PATH}:${LIBDEVMAPPER_SO_PATH}:ro"

  echo "${RBD_OPTIONS}"
  return 0
}

function show_usage(){
  USAGE="Usage: ${0##*/} [options...]
Options:
-i, --ip=IPADDR               Host IP address (Required)
-p, --worker                  Run as k8s worker
-a, --apiserver-port=PORT     Apiserver port (Default: 8080)
-a, --etcd-port=PORT          etcd client port (Default: 2379)
-v, --version=VERSION         Specify k8s version (Default: 1.3.6)
-r, --registry=REGISTRY       Registry of docker image (Default: 'gcr.io/google_containers')
-h, --help                    This help text
"

  echo "${USAGE}"
}

function get_options(){
  local PROGNAME="${0##*/}"
  local SHORTOPTS="i:wa:v:r:h"
  local LONGOPTS="ip:,apiserver-port:,etcd-port:,worker,version:,registry:,help"
  local PARSED_OPTIONS=""

  PARSED_OPTIONS="$(getopt -o "${SHORTOPTS}" --long "${LONGOPTS}" -n "${PROGNAME}" -- "$@")" || exit 1
  eval set -- "${PARSED_OPTIONS}"

  # extract options and their arguments into variables.
  while true ; do
      case "$1" in
          -i|--ip)
              export EX_IPADDR="$2"
              shift 2
              ;;
          -a|--apiserver-port)
              export EX_APISERVER_PORT="$2"
              shift 2
              ;;
          -a|--etcd-port)
              export EX_ETCD_CLIENT_PORT="$2"
              shift 2
              ;;
          -p|--worker)
              export EX_WORKER="true"
              shift
              ;;
          -v|--version)
              export EX_K8S_VERSION="$2"
              shift 2
              ;;
          -r|--registry)
              export EX_REGISTRY="$2"
              shift 2
              ;;
          -h|--help)
              show_usage
              exit 0
              shift
              ;;
          --)
              shift
              break
              ;;
          *)
              echo "Option error!" 1>&2
              echo $1
              exit 1
              ;;
      esac
  done


  if [[ -z "${EX_IPADDR}" ]] || \
   [[ -z "$(ip addr | sed -nr "s/.*inet ([^ ]+)\/.*/\1/p" | grep -w "${EX_IPADDR}")" ]]; then
    echo "IP address error, exiting..." 1>&2
    exit 1
  fi

  if [[ -z "${EX_APISERVER_PORT}" ]]; then
    export EX_APISERVER_PORT="8080"
  fi

  if [[ -z "${EX_ETCD_CLIENT_PORT}" ]]; then
    export EX_ETCD_CLIENT_PORT="2379"
  fi

  if [[ "${EX_WORKER}" != "true" ]]; then
    export EX_WORKER="false"
  fi

  if [[ -z "${EX_K8S_VERSION}" ]]; then
    export EX_K8S_VERSION="1.3.6"
  fi

  if [[ -z "${EX_REGISTRY}" ]]; then
    export EX_REGISTRY="gcr.io/google_containers"
  fi
}

# Get k8s apiservers form the list of etcd members
function get_API_Servers(){
  local APISERVER_PORT="$1"
  local ETCD_CLIENT_PORT="$2"
  local APISERVERS=""
  local APISERVER=""

  local KUBE_NODE_LIST="$(curl -s 127.0.0.1:${ETCD_CLIENT_PORT}/v2/keys/registry/minions \
                        | jq -r .node.nodes[].value \
                        | jq -r '.status.addresses[] | select(.type == "InternalIP") | .address')"
  if [[ -z "${KUBE_NODE_LIST}" ]]; then exit 1; fi

  for KUBE_NODE in ${KUBE_NODE_LIST}; do
    APISERVER="${KUBE_NODE}:${APISERVER_PORT}"
    if curl -sf -m 3 "${APISERVER}/healthz" &>/dev/null; then
      APISERVERS="${APISERVERS}","${APISERVER}"
    fi
  done

  APISERVERS="$(echo "${APISERVERS}" | cut -c 2-)"
  echo "${APISERVERS}"
}

function main(){

  get_options "$@"
  local IPADDR="${EX_IPADDR}"
  local WORKER="${EX_WORKER}"
  local APISERVER_PORT="${EX_APISERVER_PORT}"
  local ETCD_CLIENT_PORT="${EX_ETCD_CLIENT_PORT}"
  local ETCD_PROXY=""
  local APISERVER=""
  local APISERVERS=""
  local APISERVER_COUNT=5
  local KUBE_CONF_PATH="/etc/kubernetes/manifests-multi"

  export REGISTRY="${EX_REGISTRY}"
  export ARCH=amd64
  export K8S_VERSION="${EX_K8S_VERSION}"
  export ADDON_MGR_VER=v4

  echo "Copy manifests-multi to /etc/kubernetes"
  mkdir -p "${KUBE_CONF_PATH}"
  cp -rf /go/kube-conf/*.json "${KUBE_CONF_PATH}"
  cp -f /go/cp-certs.sh /etc/kubernetes

  sed -i "s|REGISTRY|${REGISTRY}|g" "${KUBE_CONF_PATH}"/*.json
  sed -i "s|ARCH|${ARCH}|g" "${KUBE_CONF_PATH}"/*.json
  sed -i "s|VERSION|v${K8S_VERSION}|g" "${KUBE_CONF_PATH}"/*.json
  sed -i "s|\"--master=127.0.0.1:${APISERVER_PORT}\"\,|\"--leader-elect=true\"\,\n              \"--master=127.0.0.1:${APISERVER_PORT}\"\,|g" "${KUBE_CONF_PATH}/master-multi.json"
  sed -i "s|\"--apiserver-count=.*\",|\"--apiserver-count=${APISERVER_COUNT}\",|g" "${KUBE_CONF_PATH}/master-multi.json"
  sed -i "s|ADDON_MGR_VER|${ADDON_MGR_VER}|g" "${KUBE_CONF_PATH}/addon-manager.json"

  # If etcd is running as a proxy, set k8s as a worker
  local MEMBER_LIST="$(curl -s http://127.0.0.1:${ETCD_CLIENT_PORT}/v2/members)"
  if [[ "${MEMBER_LIST}" == *"${IPADDR}:${ETCD_CLIENT_PORT}"* ]]; then
    ETCD_PROXY="off"
    WORKER="false"
  else
    ETCD_PROXY="on"
    WORKER="true"
  fi

  if [[ "${WORKER}" == "false" ]]; then
    APISERVERS="http://127.0.0.1:${APISERVER_PORT}"
    APISERVER="${APISERVERS}"
  else
    APISERVERS="$(get_API_Servers "${APISERVER_PORT}" "${ETCD_CLIENT_PORT}")" || exit 1
    APISERVER="$(echo "${APISERVERS}" | cut -d ',' -f 1)"
    echo '{}' > "${KUBE_CONF_PATH}/master-multi.json"
    echo '{}' > "${KUBE_CONF_PATH}/addon-manager.json"
    sed -i.back "s|\"--master=.*\",|\"--master=${APISERVER}\",|g" "${KUBE_CONF_PATH}/kube-proxy.json"
  fi

  until ! docker ps | grep -w 'k8sup-kubelet'; do
    docker stop k8sup-kubelet 1>/dev/null || true
    docker rm k8sup-kubelet 1>/dev/null || true
  done

  local RBD_OPTIONS="$(rbd_env_detector)"

  echo "Running Kubernetes ..."

  docker run \
      --volume=/:/rootfs:ro \
      --volume=/sys:/sys:ro \
      --volume=/var/lib/docker/:/var/lib/docker:rw \
      --volume=/var/lib/kubelet/:/var/lib/kubelet:rw,rslave \
      --volume=/var/run:/var/run:rw \
      --volume=/var/run/dbus:/var/run/dbus:rw \
      --volume=/run/flannel:/run/flannel:rw \
      --volume=/dev:/dev:rw \
      --volume=/opt/cni/bin:/opt/cni/bin:rw \
      --volume=/var/lib/cni/:/var/lib/cni:rw \
      --volume=/etc/cni:/etc/cni:rw \
      --volume=/etc/kubernetes/cp-certs.sh:/cp-certs.sh \
      --volume=${KUBE_CONF_PATH}/kube-proxy.json:${KUBE_CONF_PATH}/kube-proxy.json \
      --volume=${KUBE_CONF_PATH}/master-multi.json:${KUBE_CONF_PATH}/master-multi.json \
      --volume=${KUBE_CONF_PATH}/addon-manager.json:${KUBE_CONF_PATH}/addon-manager.json \
      ${RBD_OPTIONS} \
      --net=host \
      --privileged=true \
      --pid=host \
      --name=k8sup-kubelet \
      -d \
      "${REGISTRY}/hyperkube-amd64:v${K8S_VERSION}" \
      /hyperkube kubelet \
          --allow-privileged=true \
          --api-servers="${APISERVERS}" \
          --v=2 \
          --address=0.0.0.0 \
          --enable-server \
          --hostname-override="${IPADDR}" \
          --config=${KUBE_CONF_PATH} \
          --containerized \
          --network-plugin=cni \
          --network-plugin-dir=/etc/cni/net.d \
          --cluster-dns=10.0.0.10 \
          --cluster-domain=cluster.local

  echo "Waiting for any k8s apiserver connected..."
  until curl -sf "${APISERVER}/healthz" &>/dev/null; do
    sleep 1
  done

  # Try to set this node as schedulable
  echo "Uncordoning this node..."
  until docker run \
    --net=host \
    --rm=true \
    "${REGISTRY}/hyperkube-amd64:v${K8S_VERSION}" \
    /hyperkube kubectl -s "${APISERVER}" \
    uncordon "${IPADDR}" &>/dev/null; do
      sleep 5
  done
}

main "$@"
